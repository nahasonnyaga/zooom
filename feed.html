<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Threads 100 Clone - Feed</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="css/feed.css">
  <style>
    .notification {
      display: none;
      position: fixed;
      top: 1.5rem;
      right: 1.5rem;
      background: #3742fa;
      color: #fff;
      padding: 1em 1.6em;
      border-radius: 8px;
      box-shadow: 0 2px 12px #0002;
      z-index: 101;
      font-size: 1.1rem;
      min-width: 220px;
      transition: opacity 0.18s, top 0.18s;
    }
    .notification.active {
      display: block;
    }
  </style>
</head>
<body>
  <div class="login-status" id="loginStatus">
    <span id="loginText">Checking login...</span>
    <button id="loginBtn" style="display:none;" onclick="toggleLogin()">Logout</button>
  </div>
  <div id="navbar-container"></div>
  <div id="notification" class="notification" role="alert" aria-live="polite"></div>
  <main class="feed" aria-label="Threads feed">
    <div id="feed-loading" style="text-align:center;color:#888;margin:2rem 0;font-size:1.2rem;">
      Loading feed...
    </div>
    <div id="feed-list"></div>
  </main>
  <script src="js/supabase.js"></script>
  <script>
    // Navbar load
    fetch('components/navbar.html')
      .then(r => r.text())
      .then(html => document.getElementById('navbar-container').innerHTML = html);

    let currentUser = null;

    // Auth UI
    async function updateLoginUI() {
      currentUser = await window.supabaseApi.getUser();
      const loginText = document.getElementById('loginText');
      const loginBtn = document.getElementById('loginBtn');
      if (currentUser) {
        // Optionally fetch username from profile
        let username = currentUser.user_metadata?.username || currentUser.email;
        loginText.innerHTML = `<span class="logged-in">Logged in as <b>${username}</b></span>`;
        loginBtn.style.display = '';
        loginBtn.textContent = 'Logout';
      } else {
        loginText.textContent = 'Not logged in';
        loginBtn.style.display = '';
        loginBtn.textContent = 'Login';
      }
    }

    async function toggleLogin() {
      if (!currentUser) {
        window.location.href = 'signin.html';
      } else {
        await window.supabaseApi.signOut();
        showNotification('Logged out successfully.');
        setTimeout(() => window.location.reload(), 600);
      }
    }

    function showNotification(msg, timeout = 2200) {
      const notif = document.getElementById('notification');
      notif.textContent = msg;
      notif.classList.add('active');
      setTimeout(() => notif.classList.remove('active'), timeout);
    }

    // Auth check and UI update
    (async () => {
      await updateLoginUI();
      if (!currentUser) {
        window.location.href = 'signin.html';
        return;
      }
      loadFeed();
    })();

    // Feed logic using supabaseApi
    async function loadFeed() {
      const feedList = document.getElementById('feed-list');
      const feedLoading = document.getElementById('feed-loading');
      feedLoading.style.display = '';
      feedList.innerHTML = '';

      let { data: threads, error } = await window.supabaseApi.fetchThreads();
      if (error) {
        feedLoading.textContent = 'Failed to load feed. Please reload.';
        showNotification('Error loading feed.');
        return;
      }
      if (!threads || !threads.length) {
        feedLoading.style.display = 'none';
        feedList.innerHTML = '<div style="color:#888;text-align:center;margin:2.5rem 0;">No threads yet. Be the first to post!</div>';
        return;
      }
      feedLoading.style.display = 'none';

      for (const thread of threads) {
        await renderThread(thread, feedList);
      }
    }

    async function renderThread(thread, feedList) {
      // Get username from joined user or fallback to ID/email
      let userDisplay = thread.user?.username || thread.user?.email || thread.user_id?.substring(0, 7) || 'user';

      // Get replies for this thread (expand if you want full reply data)
      let replies = [];
      if (thread.replies && Array.isArray(thread.replies)) {
        replies = thread.replies;
      }

      // Load components
      const [threadCardHTML, replyCardHTML, threadActionsHTML] = await Promise.all([
        fetch('components/thread-card.html').then(r => r.text()),
        fetch('components/reply-card.html').then(r => r.text()),
        fetch('components/thread-actions.html').then(r => r.text()),
      ]);

      // Build thread HTML
      const threadDiv = document.createElement('section');
      threadDiv.className = 'thread-card';
      threadDiv.tabIndex = 0;
      threadDiv.setAttribute('aria-label', `Thread by ${userDisplay}: ${thread.content}`);

      // Thread content
      threadDiv.innerHTML = threadCardHTML
        .replace('<!-- thread content -->', escapeHtml(thread.content))
        .replace('<!-- timestamp -->', `Posted by ${escapeHtml(userDisplay)} • ${getRelativeTime(thread.created_at)}`);

      // Actions (likes, etc)
      const actionsDiv = document.createElement('div');
      actionsDiv.innerHTML = threadActionsHTML;

      // Replies section
      const replySection = document.createElement('div');
      replySection.className = 'reply-section';
      replySection.setAttribute('aria-label', 'Replies');
      for (const reply of replies) {
        let replyUser = reply.user?.username || reply.user?.email || reply.user_id?.substring(0, 7) || 'user';
        const replyDiv = document.createElement('div');
        replyDiv.className = 'reply-card';
        replyDiv.tabIndex = 0;
        replyDiv.setAttribute('aria-label', `Reply by ${replyUser}`);
        replyDiv.innerHTML = replyCardHTML
          .replace('<!-- reply content -->', escapeHtml(reply.content))
          .replace('<!-- timestamp -->', `${escapeHtml(replyUser)} • ${getRelativeTime(reply.created_at)}`);
        replySection.appendChild(replyDiv);
      }

      // Comment form
      const commentForm = document.createElement('form');
      commentForm.className = 'comment-form';
      commentForm.ariaLabel = 'Add a reply';
      commentForm.innerHTML = `
        <textarea name="reply" placeholder="Reply to this thread..." required aria-label="Reply"></textarea>
        <button type="submit">Reply</button>
      `;
      commentForm.onsubmit = (event) => addReply(event, thread.id, replySection);

      threadDiv.appendChild(actionsDiv.firstElementChild);
      threadDiv.appendChild(replySection);
      threadDiv.appendChild(commentForm);

      feedList.appendChild(threadDiv);
    }

    async function addReply(event, threadId, replySection) {
      event.preventDefault();
      if (!currentUser) {
        window.location.href = 'signin.html';
        return false;
      }
      const textarea = event.target.querySelector('textarea');
      const replyText = textarea.value.trim();
      if (!replyText) return false;

      // Save to Supabase
      const { error } = await window.supabaseApi.replyToThread(threadId, replyText);
      if (!error) {
        showNotification('Reply posted!');
        setTimeout(() => window.location.reload(), 700);
      } else {
        showNotification('Failed to post reply.');
      }
      return false;
    }

    function escapeHtml(text) {
      var div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function getRelativeTime(dateString) {
      const now = new Date();
      const date = new Date(dateString);
      const diff = Math.floor((now - date) / 1000);
      if (diff < 60) return 'just now';
      if (diff < 3600) return `${Math.floor(diff/60)}m ago`;
      if (diff < 86400) return `${Math.floor(diff/3600)}h ago`;
      return date.toLocaleDateString();
    }

    // Demo action buttons
    document.addEventListener('click', function(event) {
      if (event.target.classList.contains('action-btn')) {
        if (!currentUser) {
          window.location.href = 'signin.html';
          return;
        }
        if (event.target.classList.contains('like-btn')) {
          event.target.classList.toggle('liked');
        } else if (event.target.classList.contains('retweet-btn')) {
          event.target.classList.toggle('retweeted');
        } else if (event.target.classList.contains('bookmark-btn')) {
          event.target.classList.toggle('bookmarked');
        }
      }
    });
  </script>
</body>
</html>
